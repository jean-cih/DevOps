## Часть 1. Инструмент **ipcalc**

> Утилита **`ipcalc`** — это мощный инструмент для работы с IP-адресами, подсетями и CIDR-нотацией. Она полезна DevOps-инженерам для расчёта сетевых параметров, проверки корректности адресации и планирования инфраструктуры. 

#### 1.1 Сети и маски

##### 1) сетевой адрес *192.167.38.54/13* = 192:160.0.0/13

```
$ sudo apt install ipcalc
```

​	*Сетевой адрес = ip-адрес ^ Маска подсети*

​	*(192.167.38.54 = 11000000.10100111.00100110.00110110) ^ (13 = 11111111.11111000.00000000.00000000) = 11000000.10100000.00000000.00000000/13 = 192:160.0.0/13*

```
ipcalc 192.167.38.54/13
```

![](/report_images/image-20250625125927652.png)

##### 2) преобразование маски *255.255.255.0* в префиксную и двоичную, */15* в обычную и двоичную, *11111111.11111111.11111111.11110000* в обычную и префиксную

​	Префиксное преобразование маски 255.255.255.0 = **/24**

​	Двоичное преобразование маски 255.255.255.0 = **11111111.11111111.11111111.00000000**

```
ipcalc 255.255.255.0
```

![image-20250625130615643](\report_images\image-20250625130615643.png)

​	Преобразование маски  */15* в обычную = **255.254.0.0**

​	Преобразование маски  */15* в двоичную = **11111111.11111110.00000000.00000000**

```
ipcalc 0.0.0.0/15
```

![image-20250625130835468](\report_images\image-20250625130835468.png)

​	Преобразование маски  *11111111.11111111.11111111.11110000* в обычную = **255.255.255.240**

​	Преобразование маски  *11111111.11111111.11111111.11110000* в префиксную = **28**

```
ipcalc 0.0.0.0/255.255.255.240
```

![image-20250625131358075](\report_images\image-20250625131358075.png)

##### 3) минимальный и максимальный хост в сети *12.167.38.4* с масками: */8* , *11111111.11111111.00000000.00000000* , *255.255.254.0* и */4*

​	Сетевой адрес в сети *12.167.38.4* с маской */8* = 12.0.0.0/8

​	Минимальный хост = **12.0.0.1**

​	Максимальный хост = **12.255.255.254**

```
ipcalc 12.167.38.4/8
```

![image-20250625131446725](\report_images\image-20250625131446725.png)

​	Сетевой адрес в сети *12.167.38.4* с маской *11111111.11111111.00000000.00000000* = 12.167.0.0/16

​	Минимальный хост = **12.167.0.1**

​	Максимальный хост = **12.167.255.254**

```
ipcalc 12.167.38.4/255.255.0.0
```

![image-20250625131559244](\report_images\image-20250625131559244.png)

​	Сетевой адрес в сети *12.167.38.4* с маской *255.255.254.0* = 12.167.38.0/23

​	Минимальный хост = **12.167.38.1**

​	Максимальный хост = **12.167.39.254**

```
ipcalc 12.167.38.4/255.255.254.0
```

![image-20250625131633035](\report_images\image-20250625131633035.png)

​	Сетевой адрес в сети *12.167.38.4* с маской */4* = 0.0.0.0/4

​	Минимальный хост = **0.0.0.1**

​	Максимальный хост = **15.255.255.254**

```
ipcalc 12.167.38.4/4
```

![image-20250625131914880](\report_images\image-20250625131914880.png)

#### 1.2. локальный хост

##### Определите и запишите в отчет, можно ли получить доступ к приложению, работающему на локальном хосте, со следующих IP-адресов: *194.34.23.100* , *127.0.0.2* , *127.1.0.1* , *128.0.0.1.*

​	Можно: ***127.0.0.2* , *127.1.0.1***

​	Нельзя: ***194.34.23.100, 128.0.0.1***

> Если IP-адрес относится к Loopback, то можно получить доступ.

```
ipcalc 194.34.23.100/8
```

![image-20250625132828542](\report_images\image-20250625132828542.png)

```
ipcalc 127.0.0.2/8
```

![image-20250625132902052](\report_images\image-20250625132902052.png)

```
ipcalc 127.1.0.1/8
```

![image-20250625132922467](\report_images\image-20250625132922467.png)

```
ipcalc 128.0.0.1/8
```

![image-20250625132957944](\report_images\image-20250625132957944.png)

#### 1.3. Диапазоны и сегменты сети

##### 1) какие из перечисленных IP-адресов можно использовать как публичные, а какие только как частные: *10.0.0.45* , *134.43.0.2* , *192.168.4.2* , *172.20.250.4* , *172.0.2.1* , *192.172.0.1* , *172.68.0.2* , *172.16.255.255* , *10.10.10.10* , *192.169.168.1*

​	*Публичные:  **134.43.0.2, 172.0.2.1, 172.68.0.2, 192.172.0.1, 192.169.168.1***

```
ipcalc 134.43.0.2
```

![image-20250625133336433](\report_images\image-20250625133336433.png)

```
ipcalc 172.0.2.1
```

![image-20250625133353293](\report_images\image-20250625133353293.png)

```
ipcalc 172.68.0.2
```

![image-20250625133412891](\report_images\image-20250625133412891.png)

```
ipcalc 192.172.0.1
```

![image-20250625133432216](\report_images\image-20250625133432216.png)

```
ipcalc 192.169.168.1
```

![image-20250625133456004](\report_images\image-20250625133456004.png)

​	*Частные: **10.0.0.45, 172.20.250.4, 192.168.4.2, 172.16.255.255, 10.10.10.10***

```
ipcalc 10.0.0.45
```

![image-20250625133117411](\report_images\image-20250625133117411.png)

```
ipcalc 172.20.250.4
```

![image-20250625133139449](\report_images\image-20250625133139449.png)

```
ipcalc 192.168.4.2
```

![image-20250625133159161](\report_images\image-20250625133159161.png)

```
ipcalc 172.16.255.255
```

![image-20250625133244631](\report_images\image-20250625133244631.png)

```
ipcalc 10.10.10.10
```

![image-20250625133316021](\report_images\image-20250625133316021.png)

##### 2) какие из перечисленных IP-адресов шлюза возможны для сети *10.10.0.0/18 :* *10.0.0.1* , *10.10.0.2* , *10.10.10.10* , *10.10.100.1* , *10.10.1.255*

​	*Возможны: **10.10.0.2, 10.10.10.10, 10.10.1.255***

​	*Не возможны: **10.0.0.1, 10.10.100.1***

​	*Сетевой адрес = 10.10.0.0*

​	*Маска сети = /18 = 11111111.11111111.11000000.00000000*

​	*Широковещательный адрес = Сетевой адрес + (~Маска сети) = 10.10.0.0 + 0.0.63.255 = 10.10.63.255*

​	*Диапазон: от 10.10.0.0 до 10.10.63.255*

```
ipcalc 10.10.0.0/18
```

![image-20250625133646715](\report_images\image-20250625133646715.png)

## Часть 2. Статическая маршрутизация между двумя машинами

##### Запустим две виртуальные машины (ws1 и ws2).

##### Просмотрим существующие сетевые интерфейсы с помощью `ip a` команды:

> Утилита **`ip a`** (или `ip address`) — это часть современного сетевого инструментария **`iproute2`**, который пришёл на смену устаревшим `ifconfig`, `route` и `netstat`. DevOps-инженеры используют её для настройки и диагностики сетевых интерфейсов в Linux.  

```
ip a
```

​	**<u>ws1</u>**

![image-20250626152711222](\report_images\image-20250626152711222.png)

​	**<u>ws2</u>**

![image-20250626152320352](\report_images\image-20250626152320352.png)

> Определение: `enp0s8` - это имя сетевого интерфейса (сетевой карты) в операционных системах Linux.
>
> Состояние: DOWN (интерфейс выключен). 
>
> Тип: Сетевой интерфейс Ethernet (BRDADCAST, MULTICAST). 
>
> MTU (Maximum Transmission Unit): 1500 (стандартное значение для Ethernet). 
>
> MAC-адрес: 08:00:27:9f:4c:b3 (физический адрес сетевой карты).

**Установим следующие адреса и маски: ws1 — *192.168.100.10* , маска */16* , ws2 — *172.24.116.8* , маска */12***

> Netplan — это утилита для настройки сети в Linux, используемая в **Ubuntu (с 17.10)**, **Debian** и других дистрибутивах на основе systemd. Она заменяет традиционные инструменты вроде `ifconfig` и `/etc/network/interfaces`, предлагая **YAML-конфигурацию** и интеграцию с `systemd-networkd` и `NetworkManager`.

- Скриншоты измененного файла *etc/netplan/00-installer-config.yaml для каждой машины.*

  ​	**<u>ws1</u>**

  ![image-20250626152847448](\report_images\image-20250626152847448.png)

  ​	**<u>ws2</u>**

  ![image-20250626153004500](\report_images\image-20250626153004500.png)

##### Перезапустим сетевую службу:

```
sudo netplan apply
```

​	**<u>ws1</u>**

![image-20250625142345856](\report_images\image-20250625142345856.png)

​	**<u>ws2</u>**

![image-20250625142409948](\report_images\image-20250625142409948.png)

#### 2.1 Добавление статического маршрута вручную

##### Добавим статический маршрут от одной машины к другой и обратно с помощью:

```
ip r add
```

> Команда `ip r add` (или полная форма `ip route add`) — это часть современного сетевого стека Linux (`iproute2`), используемая для ручного управления таблицами маршрутизации. 

##### Проверим соединение между машинами:

​	**<u>ws1</u>**

```
sudo ip r add 172.24.116.8 dev enp0s8
```

![image-20250626153229104](\report_images\image-20250626153229104.png)

​	**<u>ws2</u>**

```
sudo ip r add 192.168.100.10 dev enp0s8
```

![image-20250626153217866](\report_images\image-20250626153217866.png)

#### 2.2. Добавление статического маршрута с сохранением

##### Перезагрузим машины с помощью команды:

```
reboot
```

##### Добавим статический маршрут с одной машины на другую с помощью файла */etc/netplan/00-installer-config.yaml*

- Скриншоты измененного файла */etc/netplan/00-installer-config.yaml .*

  ​	**<u>ws1</u>**

  ![image-20250626153403566](\report_images\image-20250626153403566.png)

  ​	**<u>ws2</u>**

  ![image-20250626153524453](\report_images\image-20250626153524453.png)

##### Проверим соединение между машинами.

​	**<u>ws1</u>**

```
ping -c 5 172.24.116.8
```

![image-20250626153640709](\report_images\image-20250626153640709.png)

​	**<u>ws2</u>**

```
ping -c 192.168.100.10
```

![image-20250626153632031](\report_images\image-20250626153632031.png)

## Часть 3. Утилита **iperf3**

**Запустим две виртуальные машины (ws1 и ws2).**

#### 3.1 Скорость соединения

##### Конвертируем и запишем результаты в отчет: 8 Мбит/с в МБ/с, 100 МБ/с в Кбит/с, 1 Гбит/с в Мбит/с  

|   8 Мбит/с    |      1 МБ/с       |
| :-----------: | :---------------: |
| **100 МБ/с**  | **819200 Кбит/с** |
| **1 Гбит/с ** |  **1024 Мбит/с**  |

#### 3.2. утилита **iperf3**

**Установим утилиту iperf3 с помощью команды:**

```
sudo apt install iperf3
```

> `iperf3` — это мощный инструмент для тестирования пропускной способности сети, задержек и стабильности соединения.

##### Измерим скорость соединения между ws1 и ws2

```
iperf3 -s -f K
```

![image-20250626164805354](\report_images\image-20250626164805354.png)

```
iperf3 -c 192.168.100.10 -f K
```

![image-20250626164822416](\report_images\image-20250626164822416.png)

*Скорость соединения между машинами: 69557 КБ/с*

## Часть 4. Сетевой брандмауэр

##### Запустим две виртуальные машины (ws1 и ws2).

#### 4.1. Утилита **iptables**

##### Создадим файл */etc/firewall.sh* , имитирующий брандмауэр на ws1 и ws2:

```
#!/bin/sh

# Deleting all the rules in the "filter" table (default).
iptables -F
iptables -X
```

##### Добавим в файл следующие правила подряд:

##### 1) на ws1 применить стратегию, в которой запрещающее правило прописано в начале, а разрешающее правило — в конце (это относится к пунктам 4 и 5);

##### 2) на ws2 применить стратегию, где разрешающее правило прописано в начале, а запрещающее правило — в конце (это относится к пунктам 4 и 5);

##### 3) открыть доступ на машинах к порту 22 (ssh) и порту 80 (http);

##### 4) отклонить *эхо-ответ* (машина не должна пинговаться, т.е. должна быть блокировка на ВЫХОДЕ);

##### 5) разрешить *эхо-ответ* (машина должна быть пропингована);

- Скриншоты файла */etc/firewall для каждой машины:

  ​	**<u>ws1</u>**

  ![image-20250626171050779](\report_images\image-20250626171050779.png)

  ​	**<u>ws2</u>**

  ![image-20250626171304098](\report_images\image-20250626171304098.png)

##### Запустим файлы на обеих машинах с помощью команд:

```
sudo chmod +x /etc/firewall.sh

sudo /etc/firewall.sh
```

- Скриншоты обоих запущенных файлов:

  ​	**ws1**

  ![image-20250626171742232](\report_images\image-20250626171742232.png)

  ![image-20250626171959874](\report_images\image-20250626171959874.png)

  ​	**ws2**

  ![image-20250626171747293](\report_images\image-20250626171747293.png)

  ![image-20250626171938154](\report_images\image-20250626171938154.png)

  *Если сначала стоит запрещающее правило, то оно имеет приоритет перед последующим разрешающим. Таким образом ws2 с ws1 должна пинговаться, а ws1 с ws2 не должна.*

  > `iptables` — это мощный фаервол и инструмент управления сетевым трафиком в Linux. 

#### 4.2. Утилита **nmap**

##### Используем команду **ping** , чтобы найти машину, которая не пингуется, затем используем утилиту **nmap** , чтобы показать, что хост машины работает:

​	**ws1**

```
ping -c 5 172.24.116.8

nmap -Pn 172.24.116.8
```

![image-20250626172219457](\report_images\image-20250626172219457.png)

![image-20250626172402157](\report_images\image-20250626172402157.png)

​	**ws2**

```
ping -c 5 192.168.100.10

nmap -Pn 192.168.100.10
```

![image-20250626172234881](\report_images\image-20250626172234881.png)

![image-20250626172425454](\report_images\image-20250626172425454.png)

> Nmap (Network Mapper) — это мощный инструмент для сканирования сетей и аудита безопасности

## Часть 5. Статическая сетевая маршрутизация

![image-20250626192144353](\report_images\image-20250626192144353.png)

##### Запустим пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 маршрутизатора (r1, r2))

#### 5.1 Конфигурация адресов машин

##### Настроим конфигурации машины в *etc/netplan/00-installer-config.yaml* в соответствии с сетью, показанной на рисунке.

- Скриншоты файла *etc/netplan/00-installer-config.yaml для каждой машины.*

  ​	**ws11**

  ![image-20250629153218306](\report_images\image-20250629153218306.png)

  ​	**ws21**

  ![image-20250629153459333](\report_images\image-20250629153459333.png)

  ​	**ws22**

  ![image-20250629155818952](\report_images\image-20250629155818952.png)

  ​	**r1**

  ![image-20250629162340684](\report_images\image-20250629162340684.png)

  ​	**r2**

  ![image-20250629162700188](\report_images\image-20250629162700188.png)

##### Перезапустим сетевую службу:

```
sudo netplan apply
```

**Если ошибок нет, проверьте правильность адреса машины с помощью `ip -4 a`команды.**

- Скриншоты с вызовом и выводом используемых команд.

  ```
  ip -4 a
  ```

  ​	**ws11**

  ![image-20250626215414886](\report_images\image-20250626215414886.png)

  ​	**ws21**

  ![image-20250626220557342](\report_images\image-20250626220557342.png)

  ​	**ws22**

  ![image-20250626220907089](\report_images\image-20250626220907089.png)

  ​	**r1**

  ![image-20250626215335981](\report_images\image-20250626215335981.png)

  ​	**r2**

  ![image-20250626222507866](\report_images\image-20250626222507866.png)

  **Также выполним ping ws22 с ws21. **

  ​	**ws21**

  ![image-20250626222902897](\report_images\image-20250626222902897.png)

  ​	**ws22**

  ![image-20250626222936811](\report_images\image-20250626222936811.png)

  **Аналогично выполним ping r1 с ws11.**

  ​	**ws11**

  ![image-20250626223314290](\report_images\image-20250626223314290.png)
  
  ​	**r1**
  
  ![image-20250626223217695](\report_images\image-20250626223217695.png)

#### 5.2 Включение IP-переадресации.

##### Чтобы включить IP-пересылку, выполним на маршрутизаторах следующую команду:

```
sudo sysctl -w net.ipv4.ip_forward=1
```

*При таком подходе переадресация не будет работать после перезагрузки системы.*

- Скриншоты экрана с вызовом и выводом использованной команды.

  **r1**

  ![image-20250626223851196](\report_images\image-20250626223851196.png)

  **r2**

  ![image-20250629184522840](\report_images\image-20250629184522840.png)

##### Откроем файл */etc/sysctl.conf* и добавим следующую строку:

```
net.ipv4.ip_forward = 1 
```

*При таком подходе IP-переадресация включена навсегда.*

- Скриншоты экрана измененного файла */etc/sysctl.conf .*

  **r1**

  ![image-20250626224130621](\report_images\image-20250626224130621.png)

  **r2**

  ![image-20250626224049413](\report_images\image-20250626224049413.png)
  
  > `sysctl` — это мощный инструмент для настройки и оптимизации параметров ядра Linux в реальном времени.

#### 5.3 Конфигурация маршрута по умолчанию

Вот пример вывода команды `ip r' после добавления шлюза:

```
default via 10.10.0.1 dev eth0
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.2
```

##### Настроим маршрут по умолчанию (шлюз) для рабочих станций. Для этого добавим `default`перед IP маршрутизатора в файле конфигурации:

- Скриншоты экрана файла *etc/netplan/00-installer-config.yaml .*

  ​	**ws11**

  ![image-20250629185812307](\report_images\image-20250629185812307.png)

  ​	**ws21**

  ![image-20250629190004484](\report_images\image-20250629190004484.png)

  ​	**ws22**

  ![image-20250629190341679](\report_images\image-20250629190341679.png)

##### С помощью команды `ip r` показываем, что добавился маршрут в таблицу маршрутизации:

- Скриншоты экрана с вызовом и выводом использованной команды.

  ​	**ws11**

  ![image-20250626232217676](\report_images\image-20250626232217676.png)

  ​	**ws21**

  ![image-20250626232232932](\report_images\image-20250626232232932.png)

  ​	**ws22**

  ![image-20250626232645002](\report_images\image-20250626232645002.png)
  
  > `ip r` (сокращение от `ip route`) — это основной инструмент для работы с таблицами маршрутизации в современных Linux-системах.

##### Пропингуем маршрутизатор r2 с ws11 и покажем на r2, что пинг доходит. Для этого используем команду:

```
sudo tcpdump -tn -i enp0s8
```

- Скриншоты с вызовом и выводом используемых команд.

  ​	**ws11**

  ![image-20250629191812384](\report_images\image-20250629191812384.png)

  ​	**r2**

  ![image-20250629191829676](\report_images\image-20250629191829676.png)
  
  > `tcpdump` — это мощный инструмент для анализа сетевого трафика в Linux, который DevOps-инженеры используют для диагностики сетевых проблем, мониторинга трафика и отладки сетевых сервисов.

#### 5.4 Добавление статических маршрутов

##### Добавим статические маршруты к r1 и r2 в файл конфигурации. 

##### Пример для маршрута r1 к 10.20.0.0/26:

```
# Add description to the end of the eth1 network interface:
- to: 10.20.0.0
  via: 10.100.0.12
```

- Скриншоты измененного файла *etc/netplan/00-installer-config.yaml для каждого маршрутизатора.*

  ​	**r1**

  ![image-20250629192943351](\report_images\image-20250629192943351.png)

  ​	**r2**

  ![image-20250629193131353](\report_images\image-20250629193131353.png)

##### С помощью команды`ip r` покажем таблицы маршрутизации на обоих маршрутизаторах. 

##### Вот пример таблицы r1:

```
10.100.0.0/16 dev eth1 proto kernel scope link src 10.100.0.11
10.20.0.0/26 via 10.100.0.12 dev eth1
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.1
```

- Скриншоты  экрана с вызовом и выводом использованной команды.

  ​	**r1**

  ![image-20250627135420162](\report_images\image-20250627135420162.png)

  ​	**r2**

  ![image-20250627135434976](\report_images\image-20250627135434976.png)

**На ws11 запустим команды:**

```
ip r list 10.10.0.0/18

ip r list 0.0.0.0/0
```

- Скриншоты  экрана с вызовом и выводом использованных команд.

  ​	**ws11**

  ![image-20250629194538932](\report_images\image-20250629194538932.png)

  > Из вывода команд видно, что для сети 10.10.0.0/18 был выбран маршрут, отличный от 0.0.0.0/0, хотя он попадает под маршрут по-умолчанию. Это произошло потому, что если есть явный маршрут к подсети, который соответствует адресу назначения, система будет использовать этот маршрут, даже если задан маршрут по-умолчанию (default), так как маршруты к конкретным подсетям имеют более высокий приоритет.

#### 5.5 Создание списка маршрутизаторов

Вот пример вывода утилиты **traceroute** после добавления шлюза:

```
1 10.10.0.1 0 ms 1 ms 0 ms
2 10.100.0.12 1 ms 0 ms 1 ms
3 10.20.0.10 12 ms 1 ms 3 ms
```

##### Запустим команду дампа на r1:

```
tcpdump -tnv -i enp0s8
```

##### Используем утилиту **traceroute** для получения списка маршрутизаторов на пути от ws11 до ws21:

- Скриншоты с вызовом и выводом используемых команд (tcpdump и traceroute);

  ​	**ws11**

  <img src="\report_images\image-20250629195355422.png" alt="image-20250629195355422" style="zoom:67%;" />

  ​	**r1**

  ![image-20250627142939109](\report_images\image-20250627142939109.png)

  > Каждый пакет следует определенным узлам вдоль своего пути до достижения цели, пройдя определенное количество таких узлов. При этом у каждого пакета имеется ограниченное время активности, которое определяет количество узлов, через которые он может пройти перед своим исчезновением. Этот параметр записывается в заголовке `TTL`, и каждый промежуточный маршрутизатор, через который проходит пакет, уменьшает его значение на один. Когда значение TTL достигает нуля, пакет уничтожается, и отправителю направляется уведомление о превышении времени.

  > traceroute - это утилита, которая используется для определения маршрута, который сетевой пакет принимает от отправителя к получателю.
  >
  > 1. traceroute отправляет серию сетевых пакетов (обычно 3) к указанному удаленному узлу. Первый пакет отправляется с TTL (Time-To-Live) равным 1.
  > 2. Каждый маршрутизатор, через который проходит пакет, уменьшает значение TTL на 1. Если значение TTL достигает нуля, маршрутизатор отбрасывает пакет и отправляет сообщение "Time Exceeded" (время истекло) обратно отправителю.
  > 3. traceroute получает это сообщение и записывает IP-адрес маршрутизатора, который обработал пакет с истекшим TTL.
  > 4. Затем traceroute отправляет следующий пакет с TTL, увеличенным на 1, чтобы он достиг конкретного маршрутизатора на пути. Повторяется шаг 2 и 3.
  > 5. Процесс продолжается до тех пор, пока пакет не достигнет конечного пункта (например, удаленного сервера). Как только это произойдет, traceroute получит ответ от конечного пункта.
  > 6. traceroute анализирует все полученные ответы и строит отчет о маршруте, отображая IP-адреса всех промежуточных маршрутизаторов и время задержки (ping) до каждого из них.

#### 5.6 Использование протокола **ICMP** в маршрутизации

##### Запустим на r1 захват сетевого трафика, проходящего через enp0s8 с помощью команды:

```
tcpdump -n -i enp0s8 icmp
```

##### Выполним пинг несуществующего IP-адреса (например, *10.30.0.111* ) с ws11 с помощью команды:

```
ping -c 5 10.30.0.111
```

- Скриншоты  экрана с вызовом и выводом использованных команд.

  ​	**ws11**

  ![image-20250627143747391](\report_images\image-20250627143747391.png)

  ​	**r1**

  ![image-20250627143752155](\report_images\image-20250627143752155.png)

##### Сохраним дампы образов виртуальных машин:

![image-20250627144027973](\report_images\image-20250627144027973.png)

## Часть 6. Динамическая настройка IP с использованием **DHCP**

**Установим DHCP сервер:**

```
sudo apt install isc-dhcp-server
```

##### Для r2 настройте службу **DHCP** в файле */etc/dhcp/dhcpd.conf* :

##### 1) Укажем адрес роутера по умолчанию, DNS-сервер и внутренний сетевой адрес. 

##### Вот пример файла для r2:

```
subnet 10.100.0.0 netmask 255.255.0.0 {}

subnet 10.20.0.0 netmask 255.255.255.192
{
    range 10.20.0.2 10.20.0.50;
    option routers 10.20.0.1;
    option domain-name-servers 10.20.0.1;
}
```

##### 2) Запишем `nameserver 8.8.8.8`в файл *resolv.conf*

- Скриншоты измененных файлов.

  ​	**r2**

  ![image-20250627161451643](\report_images\image-20250627161451643.png)

  ![image-20250627161613423](\report_images\image-20250627161613423.png)

##### Перезапустим службу **DHCP** с помощью команды:

```
systemctl restart isc-dhcp-server
```

​	**r2**

![image-20250627161726977](\report_images\image-20250627161726977.png)

##### Перезагрузим машину ws21 с помощью `reboot`и покажем с помощью `ip a`, что она получила адрес: 

- Скриншоты экрана с вызовом и выводом использованных команд.

  ​	**ws21**

  ![image-20250627162503640](\report_images\image-20250627162503640.png)

  **Также пропингуем ws22 с ws21.**

  ![image-20250627162546913](\report_images\image-20250627162546913.png)

##### Укажем MAC-адрес на ws11, добавив в *etc/netplan/00-installer-config.yaml* :

```
macaddress: 10:10:10:10:10:BA`,`dhcp4: true
```

- Скриншоты экрана измененного файла *etc/netplan/00-installer-config.yaml .*

  ​	**ws11**

  ![image-20250627163515105](\report_images\image-20250627163515105.png)

##### Настраиваем r1 так же, как r2, но делаем назначение адресов строго привязанным к MAC-адресу (ws11). Прогоняем те же тесты:

​        	**r1**

![image-20250628115417392](\report_images\image-20250628115417392.png)

![image-20250628115503120](\report_images\image-20250628115503120.png)

**Перезагрузим службу DHCP:**

![image-20250628115559082](\report_images\image-20250628115559082.png)

**Перезагрузим машину ws11 с помощью `reboot`и покажите с помощью `ip a`, что она получила адрес:** 

​	**ws11**

![image-20250628120450807](\report_images\image-20250628120450807.png)

##### Запросим обновление IP-адреса у ws21:

**Запросить обновление IP-адреса у ws21 до:**

​	**ws21**

![image-20250628121156549](\report_images\image-20250628121156549.png)

**Освободим текущий enp0s8:**

```
sudo dhclient -r enp0s8
```

**Зададим новый:**

```
sudo dhclient enp0s8
```

​	**ws21**

![image-20250628121516177](\report_images\image-20250628121516177.png)

**Запросим обновление IP-адреса у ws21 после:**

​	**ws21**

![image-20250628121635756](\report_images\image-20250628121635756.png)

> При настройке **DHCP** сервера использовались опции:
>
> - subnet: это ключевое слово, которое позволяет определить подсеть и её параметры
> - range: определяет диапазон IP-адресов, который может быть назначен клиентам
> - option routers: задает IP-адрес шлюза по умолчанию
> - option domain-name-servers: определяет DNS-серверы, которые будут предоставляться клиентам
> - host: позволяет назначить опции для конкретного хоста по его MAC-адресу

##### Сохраним дампы образов виртуальных машин:

![image-20250627144027973](\report_images\image-20250627144027973.png)

## Часть 7. **NАТ**

**В этой части используются конфигурации машин из 5 части, поэтому сначала выключим все машины и откатим изменения с помощью импорта конфигураций.**

**Установим на машинах сервер Apache2:**

```
sudo apt install apache2
```

##### В файле */etc/apache2/ports.conf* изменим строку  `Listen 80` на  `Listen 0.0.0.0:80` на ws22 и r1, т.е. сделаем сервер Apache2 публичным:

- Скриншоты экрана измененного файла.

  ​	**ws22**

  ![image-20250628122600532](\report_images\image-20250628122600532.png)

  ​	**r1**

  ![image-20250628122845767](\report_images\image-20250628122845767.png)

##### Запустим веб-сервер Apache на ws22 и r1 с помощью команды:

```
service apache2 start
```

- Скриншоты с вызовом и выводом использованной команды.

  ​	**ws22**

  ![image-20250628123025599](\report_images\image-20250628123025599.png)

  ​	**r1**

  ![image-20250628123013617](\report_images\image-20250628123013617.png)

##### Добавим следующие правила в брандмауэр на r2:

##### 1) удалить правила в таблице фильтров —`iptables -F`

##### 2) удалить правила в таблице «NAT» —`iptables -F -t nat`

##### 3) отбросить все маршрутизируемые пакеты —`iptables --policy FORWARD DROP`

![image-20250629230459984](\report_images\image-20250629230459984.png)

##### Запустим файл:.

```
$ sudo chmod +x /etc/firewall.sh
$ sudo /etc/firewall.sh
```

> При этих правилах ws22 не пингуется с r1 и наоборот.

##### Проверим соединение между ws22 и r1 с помощью команды:

```
ping -c 5 10.10.0.1
```

> При запуске файла с этими правилами ws22 не должен пинговаться с r1.
>

- Скриншоты с вызовом и выводом использованной команды.

  ​	**ws22**

  ![image-20250628124031659](\report_images\image-20250628124031659.png)

  ​	**r1**

  ![image-20250628124047838](\report_images\image-20250628124047838.png)

##### Добавим еще одно правило в файл:

##### 4) разрешить маршрутизацию всех пакетов протокола **ICMP**

![image-20250629230652491](\report_images\image-20250629230652491.png)

**Запустим файл:**

```
$ sudo chmod +x /etc/firewall.sh
$ sudo /etc/firewall.sh
```

> Теперь ws22 должна пинговаться c r1 и наоборот.

##### Проверим соединение между ws22 и r1 с помощью команды:

```
ping -c 5 10.10.0.1
```

​	**ws22**

![image-20250628131922330](\report_images\image-20250628131922330.png)

**Добавим в файл еще два правила:**

##### 5) включить **SNAT** , который маскирует все локальные IP-адреса из локальной сети за r2 (как определено в части 5 — сеть 10.20.0.0)

> Стоит подумать о маршрутизации как внутренних пакетов, так и внешних пакетов при установленном соединении.
>

##### 6) включите **DNAT** на порту 8080 машины r2 и добавьте внешний сетевой доступ к веб-серверу Apache, работающему на ws22

> Учесть, что при попытке подключения будет установлено новое TCP-соединение для ws22 и порта 80.
>

- Скриншоты экрана измененного файла.

  ​	**r2**

  ![image-20250629231750212](\report_images\image-20250629231750212.png)

##### Запустим файл:

```
$ sudo chmod +x /etc/firewall.sh
$ sudo /etc/firewall.sh
```

##### Проверить TCP-соединение для **SNAT** , подключившись из ws22 к серверу Apache на r1 с помощью  команды:

```
telnet 10.100.0.11 80
```

##### Проверить TCP-соединение для **DNAT** , подключившись с r1 к серверу Apache на ws22 с помощью `telnet`команды (адрес r2 и порт 8080)

```
telnet 10.100.0.12 8080
```

- Скриншоты с вызовом и выводом использованных команд.

  <img src="\report_images\image-20250628135147920.png" alt="image-20250628135147920" style="zoom: 33%;" />

<img src="\report_images\image-20250628135250160.png" alt="image-20250628135250160" style="zoom: 50%;" />

> Несмотря на то, что telnet считается устаревшим протоколом, утилита `telnet` остается полезным инструментом в арсенале DevOps инженера для быстрой диагностики сетевых сервисов.

##### Сохраним дампы образов виртуальных машин:

![image-20250627144027973](\report_images\image-20250627144027973.png)

## Часть 8. Бонус. Введение в **SSH-туннели**

**В этой части используются конфигурации машин из 5 части, поэтому сначала выключим все машины и откатим изменения с помощью импорта конфигураций.**

##### Запустим брандмауэр на r2 с правилами из Части 7:

![image-20250628135456935](\report_images\image-20250628135456935.png)

##### Запустим веб-сервер **Apache** на ws22 только на локальном хосте (т.е. в файле */etc/apache2/ports.conf* измените строку `Listen 80`на `Listen localhost:80`):

![image-20250628135547700](\report_images\image-20250628135547700.png)

##### Используем локальную переадресацию TCP с ws21 на ws22 для доступа к веб-серверу на ws22 из ws21:

```
$ ssh -L 4444:localhost:80 10.20.0.20
```

##### Используем *удаленную переадресацию TCP* с ws11 на ws22 для доступа к веб-серверу на ws22 из ws11:

```
$ ssh -R 4444:localhost:80 -p 22 ws11
```

##### Чтобы проверить, работает ли соединение на обоих предыдущих шагах, перейдем во второй терминал (например, с помощью Alt + F2) и выполните `telnet 127.0.0.1 [local port]`команду.

![image-20250704180218381](\report_images\image-20250704180218381.png)

> SSH-туннели — это мощный инструмент для безопасного доступа к ресурсам, который DevOps инженеры используют для решения различных задач, от обхода фаерволов до безопасного доступа к внутренним сервисам.

##### Сохраним дампы образов виртуальных машин:

![image-20250627144027973](\report_images\image-20250627144027973.png)
